import stripe
import logging
from common.logging.log_utils import START_OF_METHOD, END_OF_METHOD
from common.logging.error.error import Error
from common.logging.error.error_messages import INTERNAL_SERVICE_ERROR
from backend.db.model.query.sql_statements import (UPDATE_SUBSCRIPTION_STATUS_FOR_DELETION,
                                                   SELECT_USER_ID_BY_STRIPE_CUSTOMER)


class DeletePaymentStatusService:
    def __init__(self, hp_ai_db_connection_pool, webhook_secret):
        self.pool = hp_ai_db_connection_pool.pool
        self.webhook_secret = webhook_secret

    def perform_webhook_verification(self, request):
        """

        :param request:
        :return:
        """
        logging.info(START_OF_METHOD)
        payload = request.data
        sig_header = request.headers.get("Stripe-Signature")
        event = self.validate_and_construct_event(
            payload=payload,
            sig_header=sig_header,
            webhook_secret=self.webhook_secret)
        logging.info(END_OF_METHOD)
        return event

    def update_payment_status_from_event_for_deletion(self, event):
        """
        Switches the subscription status for a customer in the subscriptions table
        :param event: The id of a session generated by Stripe checkout
        :return: python int
        """
        logging.info(START_OF_METHOD)
        event_type = event['type']
        if event_type == 'customer.subscription.deleted':
            stripe_customer_id = event['data']['object']['customer']
            cnx = self.obtain_connection()
            user_id = self.fetch_user_id_given_stripe_customer(
                cnx=cnx,
                stripe_customer_id=stripe_customer_id)
            put_record_status = self.update_subscription_status_for_customer(
                cnx=cnx,
                user_id=user_id)
            cnx.close()
            response = {'putRecordStatus': put_record_status}
            logging.info(END_OF_METHOD)
            return response
        else:
            response = {'status': 'succeeded'}
            return response

    @staticmethod
    def fetch_user_id_given_stripe_customer(cnx, stripe_customer_id):
        """
        Retrieves the user id in our system
        :param cnx: The MySQLConnectionPool
        :param stripe_customer_id: The customer on the stripe end
        :return: python string
        """
        logging.info(START_OF_METHOD)
        try:
            cursor = cnx.cursor()
            cursor.execute(SELECT_USER_ID_BY_STRIPE_CUSTOMER, [stripe_customer_id])
            table = cursor.fetchall()
            user_id = int(table[0][0])
            cursor.close()
            logging.info(END_OF_METHOD)
            return user_id
        except Exception as e:
            logging.error('There was an issue retrieving the user id for a customer being deleted',
                          exc_info=True,
                          extra={'information': {'error': str(e)}})
            raise Error(INTERNAL_SERVICE_ERROR)

    @staticmethod
    def update_subscription_status_for_customer(cnx, user_id):
        """
        Updates the customer's status in our system
        :param cnx: The MySQLConnectionPool
        :param user_id: The internal id of a customer in our system
        :return:
        """
        logging.info(START_OF_METHOD)
        put_record_status = 200
        try:
            cursor = cnx.cursor()
            cursor.execute(UPDATE_SUBSCRIPTION_STATUS_FOR_DELETION, [user_id])
            cnx.commit()
            cursor.close()
            logging.info(END_OF_METHOD)
            return put_record_status
        except Exception as e:
            logging.error('There was an issue updating the customer subscription in our table',
                          exc_info=True,
                          extra={'information': {'error': str(e)}})
            return 500

    @staticmethod
    def validate_and_construct_event(payload, sig_header, webhook_secret):
        """

        :param payload:
        :param sig_header:
        :param webhook_secret:
        :return:
        """
        logging.info(START_OF_METHOD)
        try:
            event = stripe.Webhook.construct_event(
                payload, sig_header, webhook_secret
            )
            logging.info(END_OF_METHOD)
            return event
        except Exception as e:
            logging.error('There was an issue validating the webhook signature from Stripe',
                          exc_info=True,
                          extra={'information': {'error': str(e)}})
            raise Error(INTERNAL_SERVICE_ERROR)

    def obtain_connection(self):
        try:
            cnx = self.pool.get_connection()
            return cnx
        except Exception as e:
            logging.error('An issue occurred acquiring a connection to the pool',
                          exc_info=True,
                          extra={'information': {'error': str(e)}})
            raise Error(INTERNAL_SERVICE_ERROR)
